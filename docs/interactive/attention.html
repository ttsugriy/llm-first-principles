<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attention Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f8f9fa;
            color: #333;
        }
        h1 {
            color: #1a1a2e;
            border-bottom: 2px solid #4f46e5;
            padding-bottom: 10px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-top: 20px;
        }
        .main-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }
        select, input[type="range"], input[type="text"], button {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #4f46e5;
        }
        .range-value {
            text-align: center;
            font-family: monospace;
            color: #666;
            margin-top: 5px;
        }
        button {
            background: #4f46e5;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            transition: background 0.2s;
        }
        button:hover {
            background: #4338ca;
        }
        button.secondary {
            background: #6b7280;
        }
        button.secondary:hover {
            background: #4b5563;
        }
        #attention-matrix {
            width: 100%;
            min-height: 400px;
        }
        .stats {
            margin-top: 15px;
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
        }
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            font-family: monospace;
            z-index: 100;
        }
        .info-box {
            background: #e0e7ff;
            border-left: 4px solid #4f46e5;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
            font-size: 14px;
        }
        .token-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }
        .token {
            padding: 5px 10px;
            background: #e0e7ff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: monospace;
        }
        .token:hover {
            background: #4f46e5;
            color: white;
        }
        .token.selected {
            background: #4f46e5;
            color: white;
        }
        .attention-cell {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .attention-cell:hover {
            opacity: 0.8;
        }
        .formula {
            font-family: monospace;
            background: #f1f5f9;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .tab {
            flex: 1;
            padding: 8px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            background: #f8f9fa;
            font-size: 12px;
        }
        .tab.active {
            background: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }
        .section-title {
            font-weight: 600;
            margin-top: 15px;
            margin-bottom: 10px;
            color: #333;
        }
        #output-display {
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <h1>Attention Visualizer</h1>

    <div class="info-box">
        Explore how self-attention works in transformers. Enter a sentence, see how queries match keys,
        and observe how attention weights determine which tokens influence each output position.
    </div>

    <div class="container">
        <div class="main-panel">
            <div class="control-group">
                <label>Input Sentence</label>
                <input type="text" id="sentence-input" value="The cat sat on the mat"
                       placeholder="Enter a sentence...">
            </div>

            <div class="section-title">Click a query token to see what it attends to:</div>
            <div id="token-row" class="token-row"></div>

            <div class="formula" id="formula-display">
                Attention(Q, K, V) = softmax(QK<sup>T</sup> / √d<sub>k</sub>) V
            </div>

            <svg id="attention-matrix"></svg>

            <div id="output-display" style="display: none;"></div>
        </div>

        <div class="control-panel">
            <div class="control-group">
                <label>Attention Pattern</label>
                <select id="pattern-select">
                    <option value="random">Random (Untrained)</option>
                    <option value="self">Self-Attention (Identity)</option>
                    <option value="previous">Previous Token</option>
                    <option value="next">Next Token</option>
                    <option value="syntactic">Syntactic (Subject-Verb)</option>
                    <option value="positional">Distance-Based</option>
                </select>
            </div>

            <div class="control-group">
                <label>Display Mode</label>
                <div class="tabs">
                    <div class="tab active" data-mode="matrix">Matrix</div>
                    <div class="tab" data-mode="bipartite">Bipartite</div>
                </div>
            </div>

            <div class="control-group">
                <label>Masking</label>
                <select id="mask-select">
                    <option value="none">No Mask (Bidirectional)</option>
                    <option value="causal">Causal Mask (GPT-style)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Temperature: <span id="temp-value">1.0</span></label>
                <input type="range" id="temperature" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Dimension (d<sub>k</sub>): <span id="dk-value">64</span></label>
                <input type="range" id="dk" min="8" max="256" step="8" value="64">
            </div>

            <button onclick="randomizeVectors()">Randomize Q, K, V</button>
            <button class="secondary" onclick="resetVisualization()">Reset</button>

            <div class="stats">
                <div class="section-title">Statistics</div>
                <div class="stats-row">
                    <span>Selected Token:</span>
                    <span id="stat-token">-</span>
                </div>
                <div class="stats-row">
                    <span>Max Attention:</span>
                    <span id="stat-max">-</span>
                </div>
                <div class="stats-row">
                    <span>Entropy:</span>
                    <span id="stat-entropy">-</span>
                </div>
                <div class="stats-row">
                    <span>Scale Factor:</span>
                    <span id="stat-scale">-</span>
                </div>
            </div>

            <div class="stats">
                <div class="section-title">Key Insight</div>
                <div id="insight-text" style="font-family: sans-serif; font-size: 13px;">
                    Select a token to see attention patterns.
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        // State
        let tokens = [];
        let queryVectors = [];
        let keyVectors = [];
        let valueVectors = [];
        let attentionWeights = [];
        let selectedTokenIndex = null;
        let displayMode = 'matrix';

        // DOM elements
        const sentenceInput = document.getElementById('sentence-input');
        const tokenRow = document.getElementById('token-row');
        const patternSelect = document.getElementById('pattern-select');
        const maskSelect = document.getElementById('mask-select');
        const temperatureSlider = document.getElementById('temperature');
        const dkSlider = document.getElementById('dk');
        const tooltip = document.getElementById('tooltip');

        // Initialize
        function init() {
            updateTokens();
            setupEventListeners();
        }

        function setupEventListeners() {
            sentenceInput.addEventListener('input', debounce(updateTokens, 300));
            patternSelect.addEventListener('change', updateAttention);
            maskSelect.addEventListener('change', updateAttention);
            temperatureSlider.addEventListener('input', () => {
                document.getElementById('temp-value').textContent = temperatureSlider.value;
                updateAttention();
            });
            dkSlider.addEventListener('input', () => {
                document.getElementById('dk-value').textContent = dkSlider.value;
                updateAttention();
            });

            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    displayMode = tab.dataset.mode;
                    renderVisualization();
                });
            });
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function updateTokens() {
            const text = sentenceInput.value.trim();
            tokens = text.split(/\s+/).filter(t => t.length > 0);

            if (tokens.length === 0) {
                tokens = ['(empty)'];
            }

            // Reset vectors
            initializeVectors();

            // Render token selector
            renderTokenSelector();

            // Select first token by default
            if (tokens.length > 0 && selectedTokenIndex === null) {
                selectToken(0);
            } else if (selectedTokenIndex >= tokens.length) {
                selectToken(0);
            } else {
                updateAttention();
            }
        }

        function initializeVectors() {
            const dk = parseInt(dkSlider.value);
            const n = tokens.length;

            queryVectors = [];
            keyVectors = [];
            valueVectors = [];

            for (let i = 0; i < n; i++) {
                queryVectors.push(randomVector(dk));
                keyVectors.push(randomVector(dk));
                valueVectors.push(randomVector(dk));
            }
        }

        function randomVector(dim) {
            return Array.from({length: dim}, () => (Math.random() - 0.5) * 2);
        }

        function dotProduct(a, b) {
            return a.reduce((sum, val, i) => sum + val * b[i], 0);
        }

        function softmax(scores, temperature = 1.0) {
            const scaled = scores.map(s => s / temperature);
            const maxScore = Math.max(...scaled.filter(s => isFinite(s)));
            const exp = scaled.map(s => isFinite(s) ? Math.exp(s - maxScore) : 0);
            const sum = exp.reduce((a, b) => a + b, 0);
            return exp.map(e => e / sum);
        }

        function computeAttention() {
            const n = tokens.length;
            const dk = parseInt(dkSlider.value);
            const temperature = parseFloat(temperatureSlider.value);
            const pattern = patternSelect.value;
            const mask = maskSelect.value;

            attentionWeights = [];

            for (let i = 0; i < n; i++) {
                let scores = [];

                for (let j = 0; j < n; j++) {
                    let score;

                    switch (pattern) {
                        case 'self':
                            score = (i === j) ? 10 : 0;
                            break;
                        case 'previous':
                            score = (j === i - 1) ? 10 : (j === i && i === 0) ? 10 : 0;
                            break;
                        case 'next':
                            score = (j === i + 1) ? 10 : (j === i && i === n - 1) ? 10 : 0;
                            break;
                        case 'syntactic':
                            // Simple heuristic: content words attend to each other
                            const contentWords = ['cat', 'sat', 'mat', 'dog', 'ran', 'ate'];
                            const isContent_i = contentWords.some(w => tokens[i].toLowerCase().includes(w));
                            const isContent_j = contentWords.some(w => tokens[j].toLowerCase().includes(w));
                            score = (isContent_i && isContent_j) ? 5 : 1;
                            break;
                        case 'positional':
                            const distance = Math.abs(i - j);
                            score = 10 / (1 + distance);
                            break;
                        default: // random
                            score = dotProduct(queryVectors[i], keyVectors[j]) / Math.sqrt(dk);
                    }

                    // Apply causal mask
                    if (mask === 'causal' && j > i) {
                        score = -Infinity;
                    }

                    scores.push(score);
                }

                attentionWeights.push(softmax(scores, temperature));
            }

            // Update scale factor display
            document.getElementById('stat-scale').textContent =
                `1/√${dk} = ${(1/Math.sqrt(dk)).toFixed(4)}`;
        }

        function updateAttention() {
            computeAttention();
            renderVisualization();
            updateStats();
        }

        function renderTokenSelector() {
            tokenRow.innerHTML = '';
            tokens.forEach((token, i) => {
                const div = document.createElement('div');
                div.className = 'token' + (i === selectedTokenIndex ? ' selected' : '');
                div.textContent = token;
                div.onclick = () => selectToken(i);
                tokenRow.appendChild(div);
            });
        }

        function selectToken(index) {
            selectedTokenIndex = index;
            renderTokenSelector();
            updateAttention();
        }

        function renderVisualization() {
            if (displayMode === 'matrix') {
                renderMatrix();
            } else {
                renderBipartite();
            }
        }

        function renderMatrix() {
            const svg = d3.select('#attention-matrix');
            svg.selectAll('*').remove();

            const n = tokens.length;
            const margin = {top: 60, right: 40, bottom: 40, left: 80};
            const width = 600;
            const height = Math.max(300, n * 50 + margin.top + margin.bottom);
            const cellSize = Math.min(50, (width - margin.left - margin.right) / n);

            svg.attr('width', width)
               .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);

            // Color scale
            const colorScale = d3.scaleSequential(d3.interpolateBlues)
                .domain([0, 1]);

            // Draw cells
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const weight = attentionWeights[i][j];

                    g.append('rect')
                        .attr('class', 'attention-cell')
                        .attr('x', j * cellSize)
                        .attr('y', i * cellSize)
                        .attr('width', cellSize - 2)
                        .attr('height', cellSize - 2)
                        .attr('fill', colorScale(weight))
                        .attr('stroke', i === selectedTokenIndex ? '#4f46e5' : '#ddd')
                        .attr('stroke-width', i === selectedTokenIndex ? 2 : 1)
                        .on('mouseover', function(event) {
                            showTooltip(event, `${tokens[i]} → ${tokens[j]}: ${(weight * 100).toFixed(1)}%`);
                        })
                        .on('mouseout', hideTooltip)
                        .on('click', () => selectToken(i));

                    // Show weight value for selected row
                    if (i === selectedTokenIndex && weight > 0.05) {
                        g.append('text')
                            .attr('x', j * cellSize + cellSize / 2)
                            .attr('y', i * cellSize + cellSize / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '10px')
                            .attr('fill', weight > 0.5 ? 'white' : '#333')
                            .text((weight * 100).toFixed(0) + '%');
                    }
                }
            }

            // Column labels (Keys)
            g.selectAll('.col-label')
                .data(tokens)
                .enter()
                .append('text')
                .attr('class', 'col-label')
                .attr('x', (d, i) => i * cellSize + cellSize / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#555')
                .text(d => d.length > 8 ? d.slice(0, 6) + '...' : d);

            // Row labels (Queries)
            g.selectAll('.row-label')
                .data(tokens)
                .enter()
                .append('text')
                .attr('class', 'row-label')
                .attr('x', -10)
                .attr('y', (d, i) => i * cellSize + cellSize / 2)
                .attr('text-anchor', 'end')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('fill', (d, i) => i === selectedTokenIndex ? '#4f46e5' : '#555')
                .attr('font-weight', (d, i) => i === selectedTokenIndex ? 'bold' : 'normal')
                .text(d => d.length > 8 ? d.slice(0, 6) + '...' : d);

            // Axis labels
            svg.append('text')
                .attr('x', margin.left + (n * cellSize) / 2)
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .attr('fill', '#333')
                .text('Keys (what each position contains)');

            svg.append('text')
                .attr('transform', `rotate(-90)`)
                .attr('x', -(margin.top + (n * cellSize) / 2))
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .attr('fill', '#333')
                .text('Queries (what each position seeks)');
        }

        function renderBipartite() {
            const svg = d3.select('#attention-matrix');
            svg.selectAll('*').remove();

            if (selectedTokenIndex === null) return;

            const n = tokens.length;
            const width = 600;
            const height = Math.max(300, n * 40 + 100);
            const leftX = 100;
            const rightX = width - 100;

            svg.attr('width', width)
               .attr('height', height);

            const weights = attentionWeights[selectedTokenIndex];
            const maxWeight = Math.max(...weights);

            // Draw connections
            for (let j = 0; j < n; j++) {
                const weight = weights[j];
                if (weight > 0.01) {
                    svg.append('line')
                        .attr('x1', leftX + 50)
                        .attr('y1', height / 2)
                        .attr('x2', rightX - 50)
                        .attr('y2', 50 + j * 35)
                        .attr('stroke', d3.interpolateBlues(weight))
                        .attr('stroke-width', Math.max(1, weight * 10))
                        .attr('opacity', 0.8);
                }
            }

            // Query token (left side)
            svg.append('rect')
                .attr('x', leftX - 40)
                .attr('y', height / 2 - 20)
                .attr('width', 80)
                .attr('height', 40)
                .attr('rx', 8)
                .attr('fill', '#4f46e5');

            svg.append('text')
                .attr('x', leftX)
                .attr('y', height / 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('fill', 'white')
                .attr('font-weight', 'bold')
                .text(tokens[selectedTokenIndex]);

            // Key tokens (right side)
            for (let j = 0; j < n; j++) {
                const weight = weights[j];
                const intensity = Math.min(1, weight / maxWeight);

                svg.append('rect')
                    .attr('x', rightX - 40)
                    .attr('y', 30 + j * 35)
                    .attr('width', 80)
                    .attr('height', 30)
                    .attr('rx', 6)
                    .attr('fill', weight > 0.1 ? d3.interpolateBlues(0.3 + intensity * 0.5) : '#e5e7eb')
                    .attr('stroke', '#4f46e5')
                    .attr('stroke-width', weight > 0.2 ? 2 : 0);

                svg.append('text')
                    .attr('x', rightX)
                    .attr('y', 45 + j * 35)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .attr('font-size', '12px')
                    .text(tokens[j]);

                // Weight label
                svg.append('text')
                    .attr('x', rightX + 55)
                    .attr('y', 45 + j * 35)
                    .attr('text-anchor', 'start')
                    .attr('dominant-baseline', 'middle')
                    .attr('font-size', '11px')
                    .attr('font-family', 'monospace')
                    .attr('fill', '#666')
                    .text((weight * 100).toFixed(1) + '%');
            }

            // Labels
            svg.append('text')
                .attr('x', leftX)
                .attr('y', height / 2 - 35)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .attr('fill', '#333')
                .text('Query');

            svg.append('text')
                .attr('x', rightX)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .attr('fill', '#333')
                .text('Keys');
        }

        function updateStats() {
            if (selectedTokenIndex === null) return;

            const weights = attentionWeights[selectedTokenIndex];
            const maxWeight = Math.max(...weights);
            const maxIndex = weights.indexOf(maxWeight);

            // Entropy
            const entropy = -weights.reduce((sum, w) => {
                return sum + (w > 0 ? w * Math.log2(w) : 0);
            }, 0);

            document.getElementById('stat-token').textContent = tokens[selectedTokenIndex];
            document.getElementById('stat-max').textContent =
                `${tokens[maxIndex]} (${(maxWeight * 100).toFixed(1)}%)`;
            document.getElementById('stat-entropy').textContent =
                `${entropy.toFixed(2)} bits`;

            // Update insight
            updateInsight(weights, entropy);
        }

        function updateInsight(weights, entropy) {
            const n = weights.length;
            const maxEntropy = Math.log2(n);
            const peakedness = 1 - (entropy / maxEntropy);

            let insight = '';

            if (maskSelect.value === 'causal') {
                insight += 'Causal mask: can only attend to past tokens. ';
            }

            if (peakedness > 0.7) {
                insight += 'Attention is very focused (peaked distribution). ';
            } else if (peakedness < 0.3) {
                insight += 'Attention is spread across many tokens. ';
            } else {
                insight += 'Attention has moderate concentration. ';
            }

            if (parseFloat(temperatureSlider.value) > 1.5) {
                insight += 'High temperature creates softer attention.';
            } else if (parseFloat(temperatureSlider.value) < 0.5) {
                insight += 'Low temperature creates sharper attention.';
            }

            document.getElementById('insight-text').textContent = insight;
        }

        function showTooltip(event, text) {
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 20) + 'px';
            tooltip.textContent = text;
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        function randomizeVectors() {
            initializeVectors();
            patternSelect.value = 'random';
            updateAttention();
        }

        function resetVisualization() {
            sentenceInput.value = 'The cat sat on the mat';
            patternSelect.value = 'random';
            maskSelect.value = 'none';
            temperatureSlider.value = 1.0;
            dkSlider.value = 64;
            document.getElementById('temp-value').textContent = '1.0';
            document.getElementById('dk-value').textContent = '64';
            selectedTokenIndex = null;
            updateTokens();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
